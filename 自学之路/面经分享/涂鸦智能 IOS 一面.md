# 涂鸦智能  25 IOS 一面

涂鸦智能，杭州的公司，中厂级别，主要招客户端比较多。

总体用时 30 分钟，现在就是前端、后端、运维、客户端、IOS、安卓全能面......，后端最注重学历.jpg，竞争太多

1）实习经历介绍

2）为什么要做这个项目？

3）设计模式是怎么用的？

4）设计模式的作用，用一句话概括

5）单例模式是怎么实现的？作用和适用场景

**作用：**
保证一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。

**适用场景：**
需要频繁创建和销毁的对象、创建对象时耗时过多或耗资源过多但又经常用到的对象（如工具类对象、数据库或文件访问的连接池、线程池、缓存、日志对象等）。

**经典实现（双检锁）：**
这是线程安全且高效的实现方式。

```java
public class Singleton {
    // 使用volatile防止指令重排序，保证可见性
    private static volatile Singleton instance;

    // 私有化构造器，防止外部new
    private Singleton() {}

    public static Singleton getInstance() {
        // 第一次检查，避免不必要的同步
        if (instance == null) {
            // 同步锁，保证只有一个线程进入
            synchronized (Singleton.class) {
                // 第二次检查，确保在同步块内实例仍为null才创建
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**实现要点：**

1. **私有静态变量**：持有单例实例。
2. **私有构造方法**：这是关键，防止外部通过`new`创建实例。
3. **公共静态方法**：提供全局访问点。
4. **双重检查（Double-Check）**：第一重检查为了效率，避免已经存在实例时还进入同步块；第二重检查为了安全，防止多次创建。
5. **volatile关键字**：防止 `instance = new Singleton()` 这行代码被JVM指令重排序，导致其他线程拿到一个未初始化完成的对象。

6）JVM 内存回收机制，怎么判断对象是否死亡

垃圾回收（Garbage Collection, GC）首先要做的就是**判断对象是否“死亡”**（即不可能再被任何途径使用的对象）。判断方式主要有两种：

**1. 引用计数法（Java未使用）**

- **原理**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1。
- **缺点**：无法解决**对象之间循环引用**的问题。例如对象A和B相互引用，但再无其他引用指向它们，理论上应该被回收，但它们的引用计数都不为0，导致无法回收。

**2. 可达性分析算法（Java主要使用）**

- **原理**：通过一系列称为 **“GC Roots”** 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
- **可作为GC Roots的对象包括**：
  - 虚拟机栈（栈帧中的局部变量表）中引用的对象。
  - 方法区中类静态属性引用的对象。
  - 方法区中常量引用的对象。
  - 本地方法栈中JNI（即一般说的Native方法）引用的对象。

**即使被判定为不可达，对象也并非“非死不可”**。它还会经历一次“缓刑”：

1. 第一次标记并进行一次筛选（判断该对象是否有必要执行`finalize()`方法）。
2. 如果对象重写了`finalize()`方法且未被虚拟机调用过，则将其放入一个叫做`F-Queue`的队列中。
3. 稍后由一个低优先级的Finalizer线程去执行队列中各个对象的`finalize()`方法（但不保证会等待它运行结束）。
4. 稍后GC会对`F-Queue`中的对象进行**第二次标记**。如果对象在`finalize()`中成功自救（重新与引用链上的任何一个对象建立关联），它就会被移出“即将回收”的集合；否则，它就会被真正回收。

7）垃圾回收算法介绍

以下是三种基础的垃圾回收算法：

**1. 标记-清除算法**

- **过程**：首先标记出所有需要回收的对象（使用可达性分析），在标记完成后，统一回收所有被标记的对象。
- **缺点**：
  - **效率问题**：标记和清除两个过程的效率都不高。
  - **空间问题**：会产生大量**不连续的内存碎片**。碎片太多可能导致以后在分配大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集。

**2. 复制算法**

- **过程**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象**复制**到另外一块上面，然后再把已使用过的内存空间一次清理掉。
- **优点**：实现简单，运行高效，没有内存碎片。
- **缺点**：**内存缩小为了原来的一半**，代价太高。
- **应用**：现代商业虚拟机都采用这种算法来回收**新生代**。因为新生代中98%的对象都是“朝生夕死”，所以不需要按1:1的比例划分内存空间，而是将内存分为一块较大的`Eden`空间和两块较小的`Survivor`空间。每次使用`Eden`和其中一块`Survivor`。当回收时，将`Eden`和`Survivor`中存活的对象一次性复制到另一块`Survivor`空间上，最后清理掉`Eden`和刚才用过的`Survivor`空间。

**3. 标记-整理算法**

- **过程**：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。
- **优点**：避免了内存碎片，也无需浪费一半空间。
- **缺点**：移动存活对象并更新所有引用这些对象的地方是一个负重操作，需要暂停用户程序（Stop The World）。
- **应用**：主要适用于**老年代**的垃圾回收。

8）快速排序的原理

9）稳定算法和不稳定排序算法介绍

10）QPS 怎么测试的？

11）项目过程中遇到的难点

12）实习经历的收货

13）反问 IOS 发展、业务等等。

目前环境后端开发竞争激烈，大家可以在大一大二，选择前端，测开，客户端等其他方向。

### 项目

项目适用人群：做课设、毕设的小伙伴、只学习了后端（或者前端），但想要自己做项目写在简历上，这三个项目可以作为拓展点。

项目有多线程、事务管理、Redis 缓存、买票问题、线程池、大模型调用等可以写的点，而且体验会发现接口响应速度是很快的，功能也比较实用，想要参与开源项目的 Commiter 也可以提出。

智能 AI 旅游推荐平台：https://github.com/luoye6/vue3_tourism_frontend

智能 AI 校园二手交易平台：https://github.com/luoye6/vue3_trade_frontend

GPT 智能图书馆：https://github.com/luoye6/Vue_BookManageSystem

程序员小白条的编程日记：https://xbt.xiaobaitiao.top/ （分享如何拿到腾讯实习 Offer 和多个中大厂的面试机会，大学经历、求职经历、职场工作、创作经历、生活日常、**面经、技术分享、毕设项目指导**）定期更新内容，成长打怪系列，分享从大一到大四的完整面经，更新好玩的，有趣的事！看完可冲中大厂！dy同名程序员小白条，主要口述面试经历和分享我认为的实用网站，会比面经讲的详细很多，以真实面试录音为主！公粽号：**程序员落叶（秋招技巧、面经、公司投递表、谈offer）**

**欢迎关注上方公众号！感谢支持！一起进步，共勉！**