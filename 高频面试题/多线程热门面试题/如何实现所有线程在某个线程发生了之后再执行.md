# 如何实现所有线程在某个线程发生了之后再执行

> 本文作者：[程序员小白条](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)

**1.闭锁CountDownLatch**闭锁是典型的等待事件发生的同步工具类，将闭锁的初始值设置1，所有线程调用await方法等待，当事件发生时调用countDown将闭锁值减为0，则所有await等待闭锁的线程得以继续执行。

**2.阻塞队列BlockingQueue**所有等待事件的线程尝试从空的阻塞队列获取元素，将阻塞，当事件发生时，向阻塞队列中同时放入N个元素(N的值与等待的线程数相同)，则所有等待的线程从阻塞队列中取出元素后得以继续执行。

**3.信号量Semaphore**设置信号量的初始值为等待的线程数N，一开始将信号量申请完，让剩余的信号量为0，待事件发生时，同时释放N个占用的信号量，则等待信号量的所有线程将获取信号量得以继续执行。

**4.栅栏CyclicBarrier**设置栅栏的初始值为1，当事件发生时，调用barrier.wait()冲破设置的栅栏，将调用指定的Runable线程执行，在该线程中启动N个新的子线程执行。这个方法并不是让执行中的线程全部等待在某个点，待某一事件发生后继续执行。

特别注意：不能用“条件队列”，多个线程阻塞等待在条件队列上，事件发生时调用“条件队列”的notifyAll方法或者signalAll方法虽然能唤醒所有等待线程，但是只有一个线程能够获得该条件队列的锁得以调度执行，其它线程未获得锁仍将继续阻塞等待。