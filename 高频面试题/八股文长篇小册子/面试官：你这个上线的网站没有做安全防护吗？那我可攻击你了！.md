# 面试官：你这个上线的网站没有做安全防护吗？那我可攻击你了！

> 本文作者：[程序员小白条](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)

**面试官**：你这个上线的网站没有做安全防护吗？那我可攻击你了！

**候选人**：啊？我这小网站谁会攻击我啊？

引言：在当今数字化的时代，网络安全已经成为个人、企业乃至整个社会的一项关键挑战。随着互联网的普及和信息技术的迅猛发展，我们的生活和工作方式日益依赖于各种互联网服务和数据交换。然而，这种依赖也带来了越来越多的安全威胁和风险，需要我们采取积极的措施来保护个人隐私、数据安全以及整体的信息基础设施。作为开发者，我们不仅要实现功能，更要构建安全的系统防线。

## 解析答案

### 思维发散

<img src="https://pic.yupi.icu/5563/202510231945436.png" style="zoom:25%;" />

**面试官**：我们先从最常见的XSS攻击开始，你觉得在实际项目中应该如何防护？

**候选人**：让我从几个层面来思考XSS防护：

#### 前端防护层面

**思维A**：前端可以做输入验证和输出转义，比如：

```javascript
// 输入验证示例
function validateInput(input) {
    const dangerousPatterns = /<script|javascript:|on\w+\s*=/i;
    if (dangerousPatterns.test(input)) {
        throw new Error('检测到潜在危险输入');
    }
    return input;
}

// 输出转义示例
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
```

**思维B**：但前端防护容易被绕过，还需要后端配合。我觉得更重要的是实施内容安全策略(CSP)：

```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self' https://trusted.cdn.com;">
```

#### 后端防护层面

**思维A**：在后端，我们需要建立多层次的防护体系：

```java
@Component
public class SecurityConfig {
    
    // XSS过滤器
    @Bean
    public FilterRegistrationBean<XssFilter> xssFilter() {
        FilterRegistrationBean<XssFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new XssFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }
    
    // 全局输入验证
    @Bean
    public Validator validator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        return factory.getValidator();
    }
}
```

**思维B**：还可以使用专门的防护库，比如Java中的Jsoup：

```java
public class XssUtils {
    public static String cleanHtml(String html) {
        return Jsoup.clean(html, 
            Whitelist.relaxed()
                .addAttributes(":all", "style", "class")
                .removeProtocols("a", "href", "javascript"));
    }
}
```

### 深入理解常见攻击与防护

#### XSS攻击深度防护

**面试官**：刚才你提到了XSS，能具体说说不同类型的XSS攻击吗？

**候选人**：好的！XSS主要分为三种类型，每种都需要不同的防护策略：

**存储型XSS防护**：

```java
@RestController
public class CommentController {
    
    @PostMapping("/comments")
    public ResponseEntity<?> addComment(@Valid @RequestBody CommentDTO commentDTO) {
        // 1. 输入验证
        if (containsMaliciousScript(commentDTO.getContent())) {
            throw new SecurityException("评论内容包含危险代码");
        }
        
        // 2. 内容清理
        String cleanContent = HtmlUtils.htmlEscape(commentDTO.getContent());
        
        // 3. 存储到数据库
        Comment comment = commentService.saveComment(cleanContent);
        
        return ResponseEntity.ok(comment);
    }
    
    private boolean containsMaliciousScript(String content) {
        String[] dangerousPatterns = {
            "<script", "javascript:", "onload=", "onerror=", "onclick="
        };
        for (String pattern : dangerousPatterns) {
            if (content.toLowerCase().contains(pattern)) {
                return true;
            }
        }
        return false;
    }
}
```

**反射型XSS防护**：

```java
@ControllerAdvice
public class GlobalControllerAdvice {
    
    @ModelAttribute
    public void addSecurityHeaders(HttpServletResponse response) {
        // 设置安全头部
        response.setHeader("X-XSS-Protection", "1; mode=block");
        response.setHeader("X-Content-Type-Options", "nosniff");
        response.setHeader("X-Frame-Options", "DENY");
    }
}
```

#### CSRF攻击全面防护

**面试官**：CSRF攻击在实际项目中很常见，你有什么防护经验？

**候选人**：CSRF防护需要前后端配合，我通常采用以下几种方式：

**后端CSRF Token实现**：

```java
@Configuration
@EnableWebSecurity
public class CsrfSecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().csrfTokenRepository(csrfTokenRepository())
            .and()
            .addFilterAfter(new CsrfTokenLogger(), CsrfFilter.class);
    }
    
    private CsrfTokenRepository csrfTokenRepository() {
        CookieCsrfTokenRepository repository = CookieCsrfTokenRepository.withHttpOnlyFalse();
        repository.setCookiePath("/");
        return repository;
    }
}

// CSRF Token生成器
@Component
public class CsrfTokenService {
    
    public String generateToken() {
        return UUID.randomUUID().toString();
    }
    
    public void validateToken(String receivedToken, String expectedToken) {
        if (!MessageDigest.isEqual(
            receivedToken.getBytes(StandardCharsets.UTF_8),
            expectedToken.getBytes(StandardCharsets.UTF_8))) {
            throw new SecurityException("CSRF Token验证失败");
        }
    }
}
```

**前端CSRF Token使用**：

```javascript
// 自动从Cookie获取CSRF Token并添加到请求头
function setupCsrfProtection() {
    const csrfToken = getCookie('XSRF-TOKEN');
    if (csrfToken) {
        // 为所有AJAX请求添加CSRF Token
        $.ajaxSetup({
            beforeSend: function(xhr) {
                xhr.setRequestHeader('X-XSRF-TOKEN', csrfToken);
            }
        });
    }
}

// 表单自动添加CSRF Token
function addCsrfTokenToForms() {
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = '_csrf';
        input.value = getCookie('XSRF-TOKEN');
        form.appendChild(input);
    });
}
```

#### SQL注入深度防护

**面试官**：SQL注入是老生常谈但依然常见的问题，你有什么特别的防护经验？

**候选人**：SQL注入防护需要从开发习惯和架构设计两个层面来解决：

**使用预编译语句**：

```java
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // 错误的做法 - 字符串拼接
    public User findUserByNameUnsafe(String name) {
        String sql = "SELECT * FROM users WHERE name = '" + name + "'";
        // 容易被SQL注入！
        return jdbcTemplate.queryForObject(sql, User.class);
    }
    
    // 正确的做法 - 参数化查询
    public User findUserByNameSafe(String name) {
        String sql = "SELECT * FROM users WHERE name = ?";
        return jdbcTemplate.queryForObject(sql, new Object[]{name}, User.class);
    }
    
    // 使用命名参数
    public User findUserByCredentials(String username, String password) {
        String sql = "SELECT * FROM users WHERE username = :username AND password = :password";
        MapSqlParameterSource params = new MapSqlParameterSource()
            .addValue("username", username)
            .addValue("password", password);
        return namedParameterJdbcTemplate.queryForObject(sql, params, User.class);
    }
}
```

**ORM框架的安全使用**：

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String password;
}

@Repository
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // 安全的查询方式
    public User findByUsername(String username) {
        return userRepository.findByUsername(username);
    }
    
    // 避免使用原生SQL查询
    @Query("SELECT u FROM User u WHERE u.username = ?1 AND u.password = ?2")
    User findByCredentials(String username, String password);
}
```

## 欢迎交流

本文主要介绍了网络安全防护的 XSS、CSRF、SQL 注入等等，关于安全问题不仅仅是网络安全工程师要注意的，前后端各个方向的同学都要对安全问题提前做好防御！

1）网络中的用户和设备如何被验证和授权访问关键资源？是否存在强制的身份验证措施？

2）如何管理和处理发现的安全漏洞？是否有一个及时的安全更新策略？

3）是否有实时的事件监控系统来检测潜在的安全威胁？是否有预先制定的响应计划来应对安全事件？

