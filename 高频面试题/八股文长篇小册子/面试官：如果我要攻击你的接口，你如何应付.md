# 面试官：如果我要攻击你的接口，你如何应付

> 本文作者：[程序员小白条](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)

引言：在当今互联网应用中，接口安全防护是系统设计中不可或缺的重要环节。恶意请求不仅会消耗宝贵的服务器资源，影响正常用户体验，严重时甚至可能导致系统瘫痪、数据泄露等安全事故。作为Java开发者，我们需要构建多层次、纵深化的安全防护体系，从识别、防护到监控，全方位保障接口安全。本文将结合实际开发经验，分享一套从技术方案设计到具体实现的接口安全防护策略。

## 解析答案

### 思维发散

<img src="D:\知识碎片整理以及星球文章\面试鸭\面试封面\202405231637093.png" style="zoom:33%;" />

面试官首先你攻击我的网站是不对的！如果你非要攻击我的网站，我应该从哪些方面开始预防呢，我想到了以下几点，：

#### 从前端开始预防

思维A：确实是一种办法，给前端 ➕ 验证码、短信验证，或者加上谷歌认证（用户说：我谢谢你哈，消防栓）。

思维B：再次思考下还是算了，这次不想动我的前端加上如何短信验证还消耗我的💴，本来就是一个练手项目，打住❌。

#### 人工干预

思维A：哇！人工干预很累的欸，拜托。

思维B：那如果是定时人工检查进行干预处理，辅助其他检测手段呢，是不是感觉还行！

#### 使用网关给他预防

思维A：网关！好像听起来不错。

思维B：不行！我项目都没有网关，单单为了黑子增加一个网关，否决❌。

#### 日志监控

思维A：日志监控好像还不错欸，可以让系统日志的输出到时候统一监控，然后发短信告诉我们。

思维B：日志监控确实可以，发短信还是算了，拒绝一切花销哈❌。

#### 后端 AOP 自动检测

 思维A：我想到了！后端 AOP 拦截访问限流，通过自动检测将 IP + 用户ID 加入黑名单，让黑子无所遁形。我觉得可以我们来试试？

 思维B：还等什么！来试试吧！

### 基于AOP的黑名单拦截器

#### 注解设计

通过自定义注解实现声明式的接口防护配置：

```java
/**
 * 黑名单拦截注解
 * 用于标记需要受到访问频率控制和黑名单保护的接口方法
 * 
 * @author cong
 * @date 2024/05/23
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface BlacklistInterceptor {

    /**
     * 拦截字段的标识符
     * 用于区分不同用户或设备的唯一标识
     * 
     * @return {@link String }
     */
    String key() default "default";

    /**
     * 频率限制 - 每秒允许的请求次数
     * 
     * @return double
     */
    double rateLimit() default 10.0;

    /**
     * 保护限制 - 触发黑名单的违规次数阈值
     * 
     * @return int
     */
    int protectLimit() default 5;

    /**
     * 回调方法名称 - 当请求被拦截时执行的回调方法
     * 
     * @return {@link String }
     */
    String fallbackMethod();

    /**
     * 封禁时长 - 单位：小时
     * 
     * @return int
     */
    int banHours() default 24;
}
```



#### AOP切面实现

```java
@Aspect
@Component
@Slf4j
public class SecurityInterceptor {
    private final Redisson redisson;
    private RMapCache<String, Long> blacklist;
    
    // 用户限流器缓存，自动清理过期条目
    private final Cache<String, RRateLimiter> userRateLimiters = CacheBuilder.newBuilder()
            .expireAfterAccess(30, TimeUnit.MINUTES)
            .build();

    public SecurityInterceptor(Redisson redisson) {
        this.redisson = redisson;
        if (redisson != null) {
            log.info("Redisson initialized successfully, enabling security features...");
            // 初始化黑名单存储，设置24小时自动过期
            blacklist = redisson.getMapCache("security:blacklist");
            blacklist.expire(24, TimeUnit.HOURS);
        } else {
            log.error("Redisson initialization failed! Security features disabled.");
        }
    }

    @Pointcut("@annotation(com.cong.shortlink.annotation.BlacklistInterceptor)")
    public void securityPointcut() {
    }

    @Around("securityPointcut() && @annotation(interceptorConfig)")
    public Object doSecurityCheck(ProceedingJoinPoint jp, BlacklistInterceptor interceptorConfig) throws Throwable {
        // 获取请求上下文信息
        HttpServletRequest request = getCurrentRequest();
        String clientIP = getClientIP(request);
        String userIdentifier = getUserIdentifier(interceptorConfig.key(), jp.getArgs());
        
        log.debug("Security check - IP: {}, User: {}", clientIP, userIdentifier);

        // 黑名单检查
        if (isInBlacklist(userIdentifier, clientIP, interceptorConfig.protectLimit())) {
            log.warn("Blocked request from blacklisted source - User: {}, IP: {}", userIdentifier, clientIP);
            return executeFallback(jp, interceptorConfig.fallbackMethod());
        }

        // 频率限制检查
        if (!tryAcquirePermission(userIdentifier, interceptorConfig.rateLimit())) {
            handleRateLimitExceeded(userIdentifier, clientIP, interceptorConfig.protectLimit());
            log.warn("Rate limit exceeded - User: {}, IP: {}", userIdentifier, clientIP);
            return executeFallback(jp, interceptorConfig.fallbackMethod());
        }

        // 执行原方法
        return jp.proceed();
    }

    private HttpServletRequest getCurrentRequest() {
        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
        return ((ServletRequestAttributes) requestAttributes).getRequest();
    }

    private String getClientIP(HttpServletRequest request) {
        // 处理代理情况下的真实IP获取
        String ip = request.getHeader("X-Forwarded-For");
        if (StringUtils.isNotEmpty(ip) && !"unknown".equalsIgnoreCase(ip)) {
            return ip.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }

    private String getUserIdentifier(String keyConfig, Object[] methodArgs) {
        if ("default".equals(keyConfig)) {
            return "User_" + StpUtil.getLoginId().toString();
        }
        return extractKeyFromArgs(keyConfig, methodArgs);
    }

    private boolean isInBlacklist(String userIdentifier, String clientIP, int protectLimit) {
        if (protectLimit == 0) return false;
        
        Long userViolations = blacklist.getOrDefault(userIdentifier, 0L);
        Long ipViolations = blacklist.getOrDefault(clientIP, 0L);
        
        return userViolations > protectLimit || ipViolations > protectLimit;
    }

    private boolean tryAcquirePermission(String userIdentifier, double rateLimit) {
        try {
            RRateLimiter rateLimiter = userRateLimiters.get(userIdentifier, () -> {
                RRateLimiter limiter = redisson.getRateLimiter("rate_limit:" + userIdentifier);
                limiter.trySetRate(RateType.OVERALL, (long) rateLimit, 1, RateIntervalUnit.SECONDS);
                return limiter;
            });
            return rateLimiter.tryAcquire();
        } catch (Exception e) {
            log.error("Rate limiter error for user: {}", userIdentifier, e);
            return true; // 降级策略：限流器异常时允许访问
        }
    }

    private void handleRateLimitExceeded(String userIdentifier, String clientIP, int protectLimit) {
        if (protectLimit > 0) {
            // 原子性增加违规计数
            blacklist.addAndGet(userIdentifier, 1L);
            blacklist.addAndGet(clientIP, 1L);
        }
    }

    private Object executeFallback(JoinPoint jp, String fallbackMethod) 
            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        MethodSignature signature = (MethodSignature) jp.getSignature();
        Method fallback = jp.getTarget().getClass()
                .getMethod(fallbackMethod, signature.getParameterTypes());
        return fallback.invoke(jp.getThis(), jp.getArgs());
    }

    /**
     * 从方法参数中提取标识字段值
     */
    private String extractKeyFromArgs(String fieldName, Object[] args) {
        for (Object arg : args) {
            if (arg instanceof String) {
                return (String) arg;
            }
            try {
                Object value = getFieldValue(arg, fieldName);
                if (value != null) {
                    return value.toString();
                }
            } catch (Exception e) {
                log.debug("Failed to extract field {} from object: {}", fieldName, arg.getClass().getSimpleName());
            }
        }
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "无法获取用户标识字段: " + fieldName);
    }

    private Object getFieldValue(Object obj, String fieldName) throws IllegalAccessException {
        Field field = findField(obj.getClass(), fieldName);
        if (field != null) {
            field.setAccessible(true);
            Object value = field.get(obj);
            field.setAccessible(false);
            return value;
        }
        return null;
    }

    private Field findField(Class<?> clazz, String fieldName) {
        try {
            return clazz.getDeclaredField(fieldName);
        } catch (NoSuchFieldException e) {
            Class<?> superClass = clazz.getSuperclass();
            if (superClass != null) {
                return findField(superClass, fieldName);
            }
            return null;
        }
    }
}
```



### 方案特点与优势

1. **细粒度控制**：支持基于用户ID、设备标识等多种维度的访问控制
2. **弹性限流**：基于令牌桶算法实现平滑限流，避免突发流量导致的误拦截
3. **双重防护**：同时针对用户标识和IP地址进行防护，提高攻击成本
4. **降级策略**：在限流组件异常时自动降级，保证系统可用性
5. **易于扩展**：注解式配置，无需修改业务代码即可添加安全防护

## 实战应用示例

### 登录接口防护

```java
@BlacklistInterceptor(
    key = "title", 
    fallbackMethod = "handleSecurityException", 
    rateLimit = 1.0, 
    protectLimit = 3,
    banHours = 24
)
@PostMapping("/login")
public BaseResponse<String> login(@RequestBody LoginRequest loginRequest) {
    log.info("User login attempt: {}", loginRequest.getTitle());
    // 正常的登录逻辑
    return ResultUtils.success("登录成功");
}

public BaseResponse<String> handleSecurityException(LoginRequest loginRequest) {
    log.warn("Security block triggered for: {}", loginRequest.getTitle());
    return ResultUtils.error(ErrorCode.FORBIDDEN_ERROR, "访问过于频繁，请稍后重试");
}
```



### 关键业务接口防护

```java
@BlacklistInterceptor(
    key = "userId",
    fallbackMethod = "orderLimitHandler", 
    rateLimit = 5.0,
    protectLimit = 10
)
@PostMapping("/order/create")
public BaseResponse<OrderVO> createOrder(@RequestBody OrderCreateRequest request) {
    // 订单创建逻辑
    return ResultUtils.success(orderService.createOrder(request));
}

public BaseResponse<OrderVO> orderLimitHandler(OrderCreateRequest request) {
    return ResultUtils.error(ErrorCode.OPERATION_ERROR, "操作过于频繁，请稍后再试");
}
```

## 进阶防护策略

### 多层次安全防护体系

1. **参数校验**：使用Validation API对输入参数进行严格校验
2. **SQL注入防护**：使用预编译语句，避免字符串拼接
3. **XSS防护**：对用户输入进行转义处理
4. **CSRF防护**：添加CSRF Token验证
5. **敏感操作审计**：记录关键操作日志

### 智能风控系统

对于高安全要求的场景，可以进一步集成：

- 行为分析：分析用户操作模式，识别异常行为
- 设备指纹：识别唯一设备，防止多账号攻击
- 地理位置分析：检测异常登录地点
- 机器学习模型：基于历史数据训练风险识别模型

## 总结

接口安全防护是一个系统工程，需要根据实际业务场景选择合适的防护策略。基于AOP的注解式防护方案具有实现简单、侵入性低、灵活可配置等优点，适合大多数Web应用场景。但对于金融、电商等高安全要求场景，建议采用多层次、纵深化的安全防护体系，结合专业的安全组件和风控系统，构建更加坚固的安全防线。

<img src="https://pic.yupi.icu/5563/202510121035836.png" style="zoom:33%;" />

程序员小白条的编程日记：https://xbt.xiaobaitiao.top/ （分享如何拿到腾讯实习 Offer 和多个中大厂的面试机会，大学经历、求职经历、职场工作、创作经历、生活日常、**面经、技术分享、毕设项目指导**）定期更新内容，成长打怪系列，分享从大一到大四的完整面经，更新好玩的，有趣的事！看完可冲中大厂！dy同名程序员小白条，主要口述面试经历和分享我认为的实用网站，会比面经讲的详细很多，以真实面试录音为主！公粽号：**程序员落叶（秋招技巧、面经、公司投递表、谈offer）**

**欢迎关注上方公众号！感谢支持！一起进步，共勉！**

## 推荐阅读

- 技术文章：《Web应用安全防护最佳实践》
- 经典书籍：《Java核心技术卷 I》 - 包含完整的Java安全编程指南
- 开源项目：Spring Security - 企业级安全解决方案

## 欢迎交流

当谈到恶意请求时，我们可以探讨以下几个问题：

1）如何识别恶意请求的特征？

2）恶意请求的来源可能有哪些？如何区分恶意请求与正常请求？

3）如何通过日志记录和监控工具来检测和防止恶意请求对系统造成的影响？

这些问题将帮助我们深入了解恶意请求的特征、来源和防范措施，以更好地保护系统和网络安全。



