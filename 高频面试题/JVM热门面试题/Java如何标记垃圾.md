# Java如何标记垃圾

Java中的垃圾回收是通过标记-清除算法实现的。当一个对象不再被任何引用指向时，它就可以被垃圾回收器回收。

> 本文作者：[程序员小白条](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)
>
在Java中，垃圾回收器通过可达性分析算法来标记垃圾对象。可达性分析算法是从一组被称为“GC Roots”的根对象开始遍历内存中的所有对象，任何能够被遍历到的对象都被认为是“存活”的对象，而未被遍历到的对象则被认为是“垃圾”对象。

Java中的GC Roots包括以下几种类型的对象：

1. 虚拟机栈中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（Java Native Interface）引用的对象

垃圾回收器会从GC Roots开始遍历内存中的所有对象，标记出所有被引用的对象，然后将没有被标记的对象视为垃圾对象进行回收。这个过程中，需要注意的是，垃圾回收器不能回收互相引用的对象，即使这些对象已经没有任何被引用的路径，因为它们之间仍然存在一条循环引用的路径，所以它们仍然被视为“存活”的对象。

需要注意的是，Java虚拟机的垃圾回收机制是自动的，程序员无法直接干预。但是，可以通过一些手段来优化垃圾回收的效率，比如尽量避免创建大量的临时对象，避免使用过多的finalize()方法等。

**GC回收的是哪里？**

因为虚拟机栈、本地方法栈、程序计数器是线程私有的，随着线程的消亡而消亡，方法结束或者线程结束时，内存自然就跟随着回收了。 GC回收的区域是堆和方法区，为什么回收这两个区域那，因为他们是线程共享的，即java程序中所有的线程都可以访问，

**分代收集算法:**根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集;老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收;

**标记清除法:**第一步:利用可达性去遍历内存，把存活对象和垃圾对象进行标记;

第二步:在遍历一遍，将所有标记的对象回收掉;

特点:效率不行，标记和清除的效率都不高;标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC（垃圾回收）;

**标记整理法:**第一步:利用可达性去遍历内存，把存活对象和垃圾对象进行标记;第二步:将所有的存活的对象向一段移动，将端边界以外的对象都回收掉;

特点:适用于存活对象多，垃圾少的情况;需要整理的过程，无空间碎片产生;

**复制算法:**将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除;特点:不会产生空间碎片;内存使用率极低;
