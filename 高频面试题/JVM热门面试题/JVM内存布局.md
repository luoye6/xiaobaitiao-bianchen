# JVM内存布局

![](https://pic.yupi.icu/5563/202507271243052.png)

> 本文作者：[程序员小白条](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)
>
**Heap (堆区）**

堆是 OOM 故障最主要的发生区域。它是内存区域中最大的一块区域，被所有线程共享，存储着几乎所有的实例对象、数组。

Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代。再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。

堆区的调整：通过设置如下参数，可以设定堆区的初始值和最大值，比如 -Xms256M -Xmx 1024M，其中 -X 这个字母代表它是 JVM 运行时参数，ms 是 memory start 的简称，中文意思就是内存初始值，mx 是 memory max 的简称，意思就是最大内存。

在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，会形成不必要的系统压力所以在线上生产环境中 JVM 的 Xms 和 Xmx 会设置成同样大小，避免在 GC 后调整堆大小时带来的额外压力。

堆的默认空间分配：查看当前 JDK 版本所有默认的 JVM 参数：=======》java -XX:+PrintFlagsFinal -version

**Java 虚拟机栈：**

对于每一个线程，JVM 都会在线程被创建的时候，创建一个单独的栈。也就是说虚拟机栈的生命周期和线程是一致，并且是线程私有的。

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表(局部变量表:定义为一个数字数组,用于方法参数和方法内部的局部变量,包括三种数据类型:8种基本数据类型+引用数据类型地址+returnAddress类型(指向一条字节码指令的地址) )、操作数栈(操作数栈主要用于保存运算过程中的的中间结果,同时作为计算过程中变量的临时的存储空间.)、动态链接(动态链接就是讲指令中的符号引用转化为真实的方法地址(直接引用)和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

**本地方法栈：**

本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

**拓展：**

- 静态链接:当一个字节码文件被装载进JVM内部时,如果被调用的目标方法在编译器可知,且运行时期不变,这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接.对应早期绑定(早期绑定就是指被调用的目标方法如果在编译期可知,且运行时期不变,即可将这个方法与所属的类型进行绑定,这样以来,由于明确了被调用的方法是哪一个,因此可以使用静态链接的方式将符号引用转换为直接引用).
- 动态链接:如果被调用的方法在编译期无法被确定下来,只能够在程序运行期将调用方法的符号引用转换为直接引用,由于这种引用转换过程具备动态性,因此被称之为动态链接.对应晚期绑定(如果被调用方法在编译期无法被确定下来,只能在程序运行期根据实际的类型绑定相应的方法,这种绑定方式被称为晚期绑定).



**程序计数器：**

程序计数器（Program Counter Register）是一块较小的内存空间。是线程私有的。它可以看作是当前线程所执行的字节码的行号指示器

**直接内存：**

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现

**Code Cache：**

JVM 代码缓存是 JVM 将其字节码存储为本机代码的区域 。我们将可执行本机代码的每个块称为 nmethod。该 nmethod 可能是一个完整的或内联 Java 方法。
