# 说下ConcurrentHashMap原理

> 本文作者：[程序员小白条](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)

- ConcurrentHashMap是JDK1.5引入,在HashMap的基础上增加了线程安全的保障。

**总结**

做插入操作时，首先进入乐观锁，先计算得到哈希值，然后，在乐观锁中判断容器是否初始化，如果没初始化则初始化容器，如果已经初始化，则判断该hash位置的节点是否为空，如果为空，则通过CAS操作进行插入，失败则利用锁自旋保证其成功。如果该节点不为空，再判断容器是否在扩容中，如果在扩容，则帮助其扩容。如果没有扩容，则进行最后一步，先加锁，然后判断是链表还是红黑树，如果是链表，找到hash值相同的那个节点(hash冲突)，循环判断这个节点上的链表，决定做覆盖操作还是插入操作，如果是红黑树，那么用红黑树的方式进行插入，如果链表长度大于等于8，数组长度大于等于64，要进行树化。